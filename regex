```java
character class 

[abc]-> exactly matches a or b or c 
[^abc]->negation which meanss everything except a b c
[a-c]-> everything in the given range matches a,b,c
[a-c[f-h]]->union matches a,b,c,f,g,h
[a-c&&[b-c]]-> intersection matches b or c
[a-c&&[^b-c]]->substraction matches a

predefined character class 

. ->any character
\d -> A digit [0-9]
\D -> A nondigit [^0-9]
\s  -> a whitespace character [\t\n\xOB\f\r]
\S  -> a non white space character [^\s]
\w  -> a word character [a-zA-Z_0-9]
\W  -> a non word character [^\w]

boundary matches 

^ ->beggining of a line 
$ ->end of line 
\b ->a word boundary 
\B ->a non word boundary 
\A ->the begining of input 
\G ->end of previous match 
\Z ->the end of input but for the final terminator if any 
\z -> the end of input 

Pattern.CASE_INSENSITIVE();
Pattern.COMMENTS-whitespaces and comments sstarting with # are ignored untill end of line
Pattern.MULTILINE->one expression can match multiple lines

.matches(String regex); 
split(charSequence input);

X?, X??, X?+  ->X once or not at all

X*, X*?, X*+  -> X zero or more times

X+, X+?, X++  -> X one or more times

X{n},X{n}?,X{n}+  ->X exactly one time 

X{n,} , X{n,}? , X{n,}+  ->X atleast n times

X{n,m}, X{n,m}? , X{n,m}  ->X atleast n times but not more than m times 

greedy-matches longest matching group 

reluctant- matches the shortest group 

possessive -> longest match or bust (no backoff)

back refernces and groups

(...)  defines a group 

\N  refers to a matched group 

(\d\d)  a group of 2 digits 

(\d\d)/\1 two digits repeated twice

\1 refers to matched group 

XY  -> X THEN Y

X|Y   X or Y 

input.matches(regex)

//Regular Expression for Name Validation:
String nameRegex = "([A-Za-z ]+)";        
//Regular Expression for Email Id Validation:
String emailIdRegex = "([A-Za-z0-9-_]+)[@]([a-z]+)[.](com|in)";

Example: "EK-860619645:IN"

String finalRegexPatternComplete = "([A-Z]{2}[-])([\\d]{9}[:])([A-Z]{2})";

String repeatRegex = "([A-Za-z0-9]+) (\\d+) ([A-Z]+) [:] \\1 \\2 \\3";
String repeatStr = "Tom123 9090 JERRY : Tom123 9090 JERRY";

String str2 = "Thomas34";
String regex3="[A-Z]([a-z]+)\\d{2}";

        String name = "Leeroy Jenkins";
        String emailId = "leeroy.jenkins@wow.com";
        String userId = "leeroy#78jenkins";
        String accSerialId = "WoW-ABilOpZ00523ABilOpZ_a00Z9";

         //Regular Expression for Name Validation:
        String nameRegex = "([A-Za-z ]+)";
        //Regular Expression for Email Id Validation:
        String emailIdRegex = nameSplit[0]+"."+nameSplit[1]+"[@]([a-z]+)[.](com|in)";
        //Regular Expression for User Id Validation:
        String userIdRegex = nameSplit[0]+"[#]([0-9]{2})"+nameSplit[1];
        //Regular Expression for Account Serial Id Validation:
        String accSerialRegex = "(WoW)[-]([A-Za-z]{7})(\\d{5})\\2[_]([A-Za-z0-9]{5})";

	String info = "http://www.infosys.net";
String regex = "(http|https)(://)(www.|)\\w+.(com|org|net)";
```

```java
import java.util.regex.*;
		      public class RegexExample1{
			public static void main(String args[]){
//1st way
				Pattern p = Pattern.compile(".s");//. represents single character
				Matcher m = p.matcher("as");
				boolean b = m.matches();

//2nd way
				boolean b2=Pattern.compile(".s").matcher("as").matches();

//3rd way
				boolean b3 = Pattern.matches(".s", "as");

				System.out.println(b+" "+b2+" "+b3);
			}}
			o/p-true true true

				import java.util.regex.*;
		class RegexExample2{
			public static void main(String args[]){
				System.out.println(Pattern.matches(".s", "as"));//true (2nd char is s)
				System.out.println(Pattern.matches(".s", "mk"));//false (2nd char is not s)
				System.out.println(Pattern.matches(".s", "mst"));//false (has more than 2 char)
				System.out.println(Pattern.matches(".s", "amms"));//false (has more than 2 char)
				System.out.println(Pattern.matches("..s", "mas"));//true (3rd char is s)
			}
		}

import java.util.regex.*;
		class RegexExample3{
			public static void main(String args[]){
				System.out.println(Pattern.matches("[amn]", "abcd"));//false (not a or m or n)
				System.out.println(Pattern.matches("[amn]", "a"));//true (among a or m or n)
				System.out.println(Pattern.matches("[amn]", "ammmna"));//false (m and a comes more than once)
			}}

import java.util.regex.*;
		class RegexExample4{
			public static void main(String args[]){
				System.out.println("? quantifier ....");
				System.out.println(Pattern.matches("[amn]?", "a"));//true (a or m or n comes one time)
				System.out.println(Pattern.matches("[amn]?", "aaa"));//false (a comes more than one time)
				System.out.println(Pattern.matches("[amn]?", "aammmnn"));//false (a m and n comes more than one time)
				System.out.println(Pattern.matches("[amn]?", "aazzta"));//false (a comes more than one time)
				System.out.println(Pattern.matches("[amn]?", "am"));//false (a or m or n must come one time)

				System.out.println("+ quantifier ....");
				System.out.println(Pattern.matches("[amn]+", "a"));//true (a or m or n once or more times)
				System.out.println(Pattern.matches("[amn]+", "aaa"));//true (a comes more than one time)
				System.out.println(Pattern.matches("[amn]+", "aammmnn"));//true (a or m or n comes more than once)
				System.out.println(Pattern.matches("[amn]+", "aazzta"));//false (z and t are not matching pattern)

				System.out.println("* quantifier ....");
				System.out.println(Pattern.matches("[amn]*", "ammmna"));//true (a or m or n may come zero or more times)

			}}

import java.util.regex.*;
		class RegexExample5{
			public static void main(String args[]){
				System.out.println("metacharacters d....");\\d means digit

				System.out.println(Pattern.matches("\\d", "abc"));//false (non-digit)
				System.out.println(Pattern.matches("\\d", "1"));//true (digit and comes once)
				System.out.println(Pattern.matches("\\d", "4443"));//false (digit but comes more than once)
				System.out.println(Pattern.matches("\\d", "323abc"));//false (digit and char)

				System.out.println("metacharacters D...."); //D means non-digit

				System.out.println(Pattern.matches("\\D", "abc"));//false (non-digit but comes more than once)
				System.out.println(Pattern.matches("\\D", "1"));//false (digit)
				System.out.println(Pattern.matches("\\D", "4443"));//false (digit)
				System.out.println(Pattern.matches("\\D", "323abc"));//false (digit and char)
				System.out.println(Pattern.matches("\\D", "m"));//true (non-digit and comes once)

				System.out.println("metacharacters D with quantifier....");
				System.out.println(Pattern.matches("\\D*", "mak"));//true (non-digit and may come 0 or more times)

			}
		}

/*Create a regular expression that accepts alphanumeric characters only.
Its length must be six characters long only.*/

import java.util.regex.*;
		class RegexExample6{
			public static void main(String args[]){
				System.out.println(Pattern.matches("[a-zA-Z0-9]{6}", "arun32"));//true
				System.out.println(Pattern.matches("[a-zA-Z0-9]{6}", "kkvarun32"));//false (more than 6 char)
				System.out.println(Pattern.matches("[a-zA-Z0-9]{6}", "JA2Uk2"));//true
				System.out.println(Pattern.matches("[a-zA-Z0-9]{6}", "arun$2"));//false ($ is not matched)
			}}

/*Create a regular expression that accepts 10 digit numeric characters
 starting with 7, 8 or 9 only.*/

import java.util.regex.*;
		class RegexExample7{
			public static void main(String args[]){
				System.out.println("by character classes and quantifiers ...");
				System.out.println(Pattern.matches("[789]{1}[0-9]{9}", "9953038949"));//true
				System.out.println(Pattern.matches("[789][0-9]{9}", "9953038949"));//true

				System.out.println(Pattern.matches("[789][0-9]{9}", "99530389490"));//false (11 characters)
				System.out.println(Pattern.matches("[789][0-9]{9}", "6953038949"));//false (starts from 6)
				System.out.println(Pattern.matches("[789][0-9]{9}", "8853038949"));//true

				System.out.println("by metacharacters ...");
				System.out.println(Pattern.matches("[789]{1}\\d{9}", "8853038949"));//true
				System.out.println(Pattern.matches("[789]{1}\\d{9}", "3853038949"));//false (starts from 3)

			}
		}

import java.util.regex.Pattern;
import java.util.Scanner;
import java.util.regex.Matcher;
		public class RegexExample8{
			public static void main(String[] args){
				Scanner sc=new Scanner(System.in);
				while (true) {
					System.out.println("Enter regex pattern:");
					Pattern pattern = Pattern.compile(sc.nextLine());
					System.out.println("Enter text:");
					Matcher matcher = pattern.matcher(sc.nextLine());
					boolean found = false;
					while (matcher.find()) {
						System.out.println("I found the text "+matcher.group()+" starting at index "+
								matcher.start()+" and ending at index "+matcher.end());
						found = true;
					}
					if(!found){
						System.out.println("No match found.");
					}
				}
			}
		}

		Enter regex pattern: java
		Enter text: this is java, do you know java
		I found the text java starting at index 8 and ending at index 12
		I found the text java starting at index 26 and ending at index 30

		class Tester {
	public static void main(String args[]) {
		String regex1 = "Welcome.*";
		String str1 = "Welcome to India";

		String regex2 = "Welcome to (India|Mysore)";
		String str2 = "Welcome to Mysore";

		String regex3 = "[^Welcome]";
		String str3 = "1";

		System.out.println(str1.matches(regex1));
		System.out.println(str2.matches(regex2));
		System.out.println(str3.matches(regex3));

	}
}

Output:

true
true
true

//tryout 2

class Tester {
	public static void main(String args[]) {
		String regex1 = "[Employee].?";
		String str1 = "Employeee";

		String regex2 = "[Employee].*";
		String str2 = "Employeee";

		String regex3 = "[P-Z]{8,10}";
		String str3 = "QRSTUVWX";

		String regex4 = "[Employee]+";
		String str4 = "Employeeeeee";

		System.out.println(str1.matches(regex1));
		System.out.println(str2.matches(regex2));
		System.out.println(str3.matches(regex3));
		System.out.println(str4.matches(regex4));

	}
}

Output:

false
true
true
true

//tryout3

class Tester {
	public static void main(String args[]) {
		String regex1 = "[\\w]+ [\\w]+ [\\d]+";
		String str1 = "Java Training 123";

		String regex2 = "[\\w]+ [\\t] [\\w]+";
		String str2 = "Java 	 Training";

		String regex3 = "[\\w]+ [^\\w]+ [\\d]+";
		String str3 = "Java Training 123";

		String regex4 = "[\\D]+ [\\W]+";
		String str4 = "Java *";

		System.out.println(str1.matches(regex1));
		System.out.println(str2.matches(regex2));
		System.out.println(str3.matches(regex3));
		System.out.println(str4.matches(regex4));

	}
}

Output:

true
true
false
true

//password valdidation

class Tester {
	public static boolean isValidPassword(String password) {
		boolean flag = false;
		String regex = "[A-Za-z]{8,10}[0-9]{4}";

		if (password.matches(regex)) {
			flag = true;
		}
		return flag;
	}

	public static void main(String[] args) {
		String password = "gftdrstr8645";
		System.out.println("The password of the customer is " + password);
		if (isValidPassword(password))
			System.out.println("The password is valid!");
		else
			System.out.println("The password is not valid!");
	}
}

		Output:

		The password of the customer is gftdrstr8645
		The password is valid

//email validation

class Tester {

	public static boolean isValidEmail(String email) {
		boolean flag = false;
		String regex = "[a-zA-Z0-9]+@[a-zA-Z]+\\.(com|in)";

		if (email.matches(regex)) {
			flag = true;
		}
		return flag;
	}

	public static void main(String[] args) {
		String email = "steve123@gmail.com";
		System.out.println("The Email Id of the customer is " + email);
		if (isValidEmail(email))
			System.out.println("The Email Id is valid!");
		else
			System.out.println("The Email Id is invalid!");
	}
}

Output:

The Email Id of the customer is steve123@gmail.com
The Email Id is valid!

String regex="[A-Z][A-Za-z]{1,}";

Valid values:
Abc, AB, AbcDEfgh
Invalid values:
A, abc, a
```

# capstone imp code

```java
private MobileServiceDAO dao =  new MobileServiceDAOImpl();
```

```java
Let regex;

/* shorthand character classes */
regex = /d/; // matches any digit, short for [0-9]
regex = /D/; // matches non-digits, short for [^0-9]
regex = /S/; // matches non-white space character
regex = /s/; // matches any white space character
regex = /w/; // matches character, short for [a-zA-Z_0-9]
regex = /W/; // matches non-word character [^w]
regex = /b/; // Matches a word boundary where a word character is [a-zA-Z0-9_]
These meta characters boast a pre-defined meaning and make various typical patterns easier to use.

/* matching using quantifiers */
regex= /X./; // matches any character
regex= /X*/; // Matches zero or several repetitions of letter X, is short for {0,}
regex= /X+-/; // matches one or more repetitions of letter X, is short for {1,}
regex= /X?/; // finds no or exactly one letter X, is short for is short for {0,1}.
regex= // d{3}; // matches three digits. {} describes the order of the preceding liberal
regex= // d{1,4} ; // means d must occur at least once and at a maximum of four
A quantifies helps developers to define how often an element occurs.

/* character ranges */
regex = /[a-z]/; // matches all lowercase letters
regex = /[A-Z]/; // matches all uppercase letters
regex = /[e-l]/; // matches lowercase letters e to l (inclusive)
regex = /[F-P]/; // matches all uppercase letters F to P (inclusive)
regex = /[0-9]/; // matches all digits
regex = /[5-9]/; // matches any digit from 5 to 9 (inclusive)
regex = / [a-d1-7]/; // matches a letter between a and d and figures from 1 to 7, but not d1
regex = /[a-zA-Z]/; // matches all lowercase and uppercase letters
regex = /[^a-zA-Z]/; // matches non-letters

/* matching using anchors */
regex = / ^The/; // matches any string that starts with “The”
regex = / end$/; // matches a string that ends with end
regex = / ^The end$/; // exact string match starting with “The” and ending with “End”

/* escape characters */
regex = / a/; // match a bell or alarm
regex = / e/; // matches an escape
regex = / f/; // matches a form feed
regex = / n/; // matches a new line
regex = / Q…E/; // ingnores any special meanings in what is being matched
regex = / r/; // matches a carriage return
regex = / v/; // matches a vertical tab
It is critical to note that escape characters are case sensitive

/* matching using flags */
regex = / i/; // ignores the case in pattern ( upper and lower case allowed)
regex = / m/; // multi-line match
regex = / s/; // match new lines
regex = / x/; // allow spaces and comments
regex = / j/; // duplicate group names allowed
regex = / U/; // ungreedy match
Besides the regular expressions, flags can also be used to help developers with pattern matching.

/* matching a specific string */
regex = /sing/; // looks for the string between the forward slashes 9case-sensitive)… matches “sing”, “sing123”
regex = /sing/i; // looks for the string between the forward slashes (case-insensitive)... matches "sing", "SinNG", "123SinNG"
regex = /hello/g; // looks for multiple occurrences of string between the forward slashes...

/* groups */
regex = /it is (sizzling )?hot outside/; // matches "it is sizzling hot outside" and "it is hot outside"
regex = /it is (?:sizzling )?hot outside/; // same as above except it is a non-capturing group
regex = /do (dogs) like pizza 1/; // matches "do dogs like pizza dogs"
regex = /do (dogs) like (pizza)? do 2 1 like you?/; // matches "do dogs like pizza? do pizza dogs like you?"

/* look-ahead and look-behind */
regex = /d(?=r)/; // matches 'd' only if it is followed by 'r', but 'r' will not be part of the overall regex match
regex = / (?<=r)d /; // matches 'd' only if it is proceeded by an 'r', but 'r' will not be part of the overall regex match


// validates the brand
	// brand should always start with a upper case alphabet 
	// and can be followed by one or more alphabets (lower case or upper case) 
	public Boolean isValidBrand(String brand){
		String regex="[A-Z][A-Za-z]{1,}";
		return brand.matches(regex);
	}



	// validates the IMEINumber
	// it should be a 16 digit number 

public Boolean isValidIMEINumber(Long iMEINumber) {
		String number=iMEINumber.toString();
		if(number.length()==16) {
			return true;
		}
		else {
			return false;
		}
	}



 public Boolean isValidStatus(IssueStatus status)
 {
	// Your Code Goes Here
     String sta=status.toString().toUpperCase();
     if(sta.equals("OPEN")||sta.equals("IN_PROGRESS")) {
	 return true;
     }

	return false;
 }
}





	// validates the contact number
	// should contain 10 numeric characters and should not contain 10 repetitive characters
	public Boolean isValidContactNumber(Long contactNumber) {
		String check = Long.toString(contactNumber);
		String regex = "([0-9]{10})";
		String regexAvoid = "([0-9])\\1{9}";
		if(check.matches(regexAvoid))
			return false;
		else if(check.matches(regex))
			return true;
		return false;
	}
	
	
	// validates the customer name
	// should contain at least one word and each word separated by a single space should contain at least one letter.
	// the first letter of every word should be an upper case character 
	public Boolean isValidCustomerName(String customerName) {
		String regex="(([A-Z])([a-z])+([\\s]?))+";
		if(customerName.matches(regex))
		return true;
		else return false;
	}
}



public Boolean isValidName (string name)
{
//your code goes here
String regex-"[A-Za-z]{3,}";
if(name!=null &&name.matches(regex)
return true;
else
return false;
}



public Boolean isValidPublisher(String publ1isher)
{
// your code goes her 
if((publisher.equalsIgnorecase("DCD") || publisher.equalsIgnoreCase("MARVAL") &&
(Publisher!=null) && (publisher.isEmpty()) && (publisher.isBlank()))
return true;
else
return false;




 public BooleanisValidPhoneNo(Long phoneNo)
{

String regex = "([0-9]) (\\1{9})"; 
String regex1 = "[0-9]{10}"; 
return (phoneNo.toString().matches(regex1)&& !phoneNo.toString().matches(regex) ) ;
}


 public Boolean isValidUserName (String userName)
{
if(userName.isBlank() || userName.isEmpty()) 
{ 
return false;
}
String regex ="([A-Z] [A-Za -z]+) ([A-Z][A-Za-z]+)?"; 
return userName.matches(regex);

}


//valid applicant name

public Boolean isValidApplicantName(String applicantName) 
{
	String regexString="([A-Za-z]{3,})+";
	if(applicantName!=null)&&(!applicantName.isBlank())&&(!applicantName.isEmpty())&&(applicantName.matches(regex))
	{
		return true;
	}
	else 
		return false;
			
}

public Boolean isValidBookId(Integer bookId)
{
return bookId.toString().length()==6;
}

public Boolean isValidGenre(String genre)
{
String regex="(Adventure|Mystery|Fiction|History)";
return genre.matches(regex);
}

public Boolean isValidName(String name)
{
if(name.isEmpty()||name.isBlank())
{
return false;
}
return name.matches("([A-Z][a-z]+)([A-Z][a-z]+){0,9})";
}
}


 public Boolean isValidReportedOn(LocalDate reportedOn)
 {
	// Your Code Goes Here
     if(reportedOn.isAfter(LocalDate.now())|| reportedOn==null) {
	 return false;
     }

return true;
 }

